import           Control.Monad                  ( guard )
import           Data.List                      ( sortOn )
import           Data.List.Split                ( splitOn )
import           Data.Maybe                     ( isJust, fromJust )
import           Debug.Trace                    ( trace )
import           Text.Megaparsec
import           Text.Megaparsec.Char
import           Paths_aoc20_hs

{-
- Overall strategy
- ----------------
-
- Each rule should be turned into a parser of its own: when we apply this parser
- to a message, that will tell us whether the message fits the rules. Since we
- only care about whether the message is successfully parsed, the return type
- of the parser can simply be ().
-
- Therefore, to parse the rules, we need a Parser that can return a Parser ()
- 
-    ruleParser :: Parser (Parser ())
-
-    parseRule :: String -> Parser ()
-    parseRule rule ~= runParser ruleParser rule   -- I just use ~= as it hides all
-                                                     parsing implementation details.
-
-    [rules, messages] = map lines . splitOn "\n\n" $ input
-    parsers = map parseRule rules
-
- which seems like a nice setup, *except* that `ruleParser` depends critically on
- the other parsers that are generated by `parseRule`. For example, if the rule is
- 8 11 (like rule 0), then ruleParser should return the parser
-
-     getParser 8 >> getParser 11 >> return ()
-
- where `getParser 8` refers to the application of `parseRule` to rule number 8.
- This leads to a recursive function, which is in practice OK, but if poorly implemented
- can lead to a lot of wasted calls.
-
- The solution I found is similar to the standard memoisation model in Haskell,
- where the parsers are stored in a map over a list. In practice, first we sort the
- rules according to their numbers, and then map `parseRule` over them so that to find
- rule number N we simply need to index the list.
-
- The rule-parsing functions are still recursive, but it turns out that much of the
- list is memoised (I'm not 100% sure why some parts of it aren't). I suspect that
- GHC is doing some black magic under the hood which I don't really understand, but
- I'm not complaining! The only catch is that all of these functions depend on the
- rules which are passed to them. That means that the ruleset must be threaded through
- each function call. This adds a bit of syntax overhead, but is quite tolerable.
-
-}


main :: IO ()
main = do
  fname <- getDataFileName "d19.txt"
  input <- readFile fname
  let [rules, messages] = map lines $ splitOn "\n\n" input
      sortedRules       = sortOn extractRuleNumber rules

  putStr "Part 1: "
  let parser0   = getParser' sortedRules 0
      successes = map (parseMessage parser0) messages
  print $ length (filter id successes)

  putStr "Part 2: "
  let parser42   = getParser' sortedRules 42
      parser31   = getParser' sortedRules 31
      -- The new rule 0 is parser8' >> parser31', which translates
      -- to (n + m) parser42's and m parser31's, where n > m > 0.
      combinedP  = do
        n42 <- some (try parser42)
        n31 <- some (parser31)
        guard $ length n42 > length n31
        return ()
      successes' = map (parseMessage combinedP) messages
  print $ length (filter id successes')


-- Step 1: Parse the rules given as strings and return parsers
type Parser = Parsec () String

extractRuleNumber :: String -> Int
extractRuleNumber = read . head . splitOn ":"

getParser' :: [String] -> Int -> Parser ()
getParser' sortedRules = p
 where
  -- This is tantalisingly close to the typical memoisation model in Haskell,
  -- and almost perfectly behaves that way, as `pRuleToParser` is only being
  -- called 159 times for Part 1 of the problem (there are 136 rules in the
  -- puzzle input, so it should only be called a maximum of 136 times).
  --
  -- Previous iterations of this function:
  --   - I wrote getParser' sortedRules n = p n (not eta-reduced) (1461 calls).
  --   - I used an IntMap instead of a plain list (198,696 calls).
  --   - I also tried it with a plain old association list. (938 calls)
  table = map (snd . parseRule sortedRules) sortedRules
  p     = (table !!)

parseRule :: [String] -> String -> (Int, Parser ())
parseRule rules = fromJust . parseMaybe (pRuleToParser rules)

pRuleToParser :: [String] -> Parser (Int, Parser ())
pRuleToParser srules = do
  ruleNumber <- read <$> some digitChar
  _          <- string ": "
  ruleParser <- try (pOrRule srules) <|> try (pAndRule srules) <|> (pCharRule srules)
  -- From these traced values we can tell that the same rule is being parsed
  -- multiple times.
  return $ show ruleNumber `trace` (ruleNumber, ruleParser)

pOrRule :: [String] -> Parser (Parser ())
pOrRule srules = do
  leftParser  <- pAndRule srules
  _           <- string "| "
  rightParser <- pAndRule srules
  return $ (try leftParser <|> rightParser) >> return ()
pAndRule :: [String] -> Parser (Parser ())
pAndRule srules = do
  ruleNumbers <- some $ (read <$> some digitChar) <* space
  return $ mapM_ (getParser' srules) ruleNumbers
pCharRule :: [String] -> Parser (Parser ())
pCharRule _ = do
  _ <- char '"'
  c <- anySingle
  _ <- char '"'
  return $ char c >> return ()

-- Run a parser on a given message.
parseMessage :: Parser () -> String -> Bool
parseMessage parser message = isJust $ parseMaybe parser message
